# 4 Go 语言的并发模式

## 约束

并发代码保证操作安全的方法：

- 用于共享内存的同步原语(如 Sync.Mutex)
- 通过通信共享内存来进行同步(如 channel)

隐式并发安全：

- 不会发生改变的数据
- 受到保护的数据

两种可能的约束：

- 特定约束：通过公约实现约束时，无论是由语言社区、所在团队，或者代码库设置
- 词法约束：使用词法作用域仅公开用于多个并发进程的正确数据和并发原语

## for-select 循环

- 向 channel 发送迭代变量
- 循环等待停止

## 防止 goroutine 泄漏

终止 goroutine 的方法：

- 当它完成了它的工作
- 因为不可恢复的错误，它不能继续工作
- 当它被告知需要停止工作

## or-channel

将多个 done channel 合并成单一的 done channel，在这个复合 done channel 的任意一个 channel 关闭的时候，关闭整个 done channel。

## 错误处理

一般来说，你的并发进程应该把他们的错误发送到程序的另一部分，它有程序状态的完整信息，并可以做出更明智的决定。

如果 goroutine 可能产生错误，那么这些错误应该与结果类型紧密结合，并且通过相同的通信线传递，就像常规的同步函数。

## pipeline

pipeline 是一系列将数据输入，执行操作并将结果数据传回的系统。我们称这些操作都是 pipeline 的一个 stage。

pipeline stage 的属性：

- 一个输入的参数与返回值类型相同的 stage
- 一个 stage 必须通过编程语言进行“实化”之后才被当做参数四处传递。

## 构建 pipeline 的最佳实践

生成器函数：将一组离散值转换为一个 channel 上的数据流。这种类型的函数被称为生成器。

## 一些遍历的生成器

## 扇出，扇入

- 扇出：用于描述多个 goroutine 以处理来自 pipeline 的输入的过程。
- 扇入：描述将多个结果组合到一个 channel 的过程。

考虑 stage 使用扇出模式的条件：

- 它不依赖于之前 stage 计算的值
- 运行需要很长时间

**注意：**原生的扇出与扇入算法的实现，仅在结果到达的顺序不重要的情况。

## or-done-channel

## tee-channel

tee-channel 从类 UNIX 系统中的 tee 命令中获得 channel 的名字。可以将它传递给一个读channel，并且它会返回两个单独的 channel，以获得相同的值。

## bridge-channel

桥接 channel：将充满 channel 的 channel (<- chan <- chan interface{}) 拆解为一个简单的 channel。

## 队列排队

排队可以提高系统整体性能的唯一适用情况：

- 在一个 stage 批处理请求可以节省时间
- 在一个 stage 中产生的延迟会在系统中产生一个反馈回环。对应负反馈循环、向下螺旋。甚至是死亡螺旋。

利特尔法则： `L=λW`

- L：系统中平均负载数
- λ：负载的平均到达率
- W：负载在系统中花费的平均时间

## context 包

context 包的两个两个主要目的：

- 提供一个可以取消调用图分支的 API
- 提供用于通过呼叫传输请求范围数据的数据包
  - 使用的键值必须满足 Go 语言的可比性概念，即运算符 `==` 和 `!=` 在使用时需要返回正确的结果
  - 返回值必须安全，才能从多个 goroutine 访问

关于 context 的实例中存储什么：

- 仅将上下文值用于传输进程和请求的请求范围数据，API 边界，而不是将可选参数传递给函数
- 启发式建议
  - 数据应该通过进程或 API 边界：如果在进程的内存中生成数据，那么除非通过 API 边界传递数据，否则可能不是一个很好的选择
  - 数据应该是不可变的：如果不是，那么根据定义，存储的内容不是来自请求的内容
  - 数据应趋向简单类型：如果请求范围数据是为了传递进进程和 API 边界，那么如果另一方不需要导入一个复杂的包的图，那么将这些数据拉出就容易的多
  - 数据应该是数据，而不是类型与方法：操作是逻辑的，属于消耗这些数据的东西
  - 数据应该用于修饰操作，而不是驱动操作：如果算法根据 context 中包含或不包含的内容而有所不同，可能会跨越可选参数的范围
